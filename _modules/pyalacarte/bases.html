<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyalacarte.bases &mdash; pyalacarte 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyalacarte 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyalacarte 0.1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyalacarte.bases</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot; Various basis function objects specialised for parameter learning.</span>

<span class="sd">    To make a new basis object, see the documentation of the Basis class.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">gammaincinv</span><span class="p">,</span> <span class="n">expit</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">params_to_list</span><span class="p">,</span> <span class="n">Positive</span>
<span class="kn">from</span> <span class="nn">.hadamard</span> <span class="kn">import</span> <span class="n">hadamard</span>


<span class="c">#</span>
<span class="c"># Basis objects</span>
<span class="c">#</span>

<div class="viewcode-block" id="Basis"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.Basis">[docs]</a><span class="k">class</span> <span class="nc">Basis</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; The base Basis class. To make other basis classes, make sure they are</span>
<span class="sd">        subclasses of this class to enable concatenation and operation with the</span>
<span class="sd">        machine learning algorithms.</span>

<span class="sd">        Example:</span>
<span class="sd">            Basis concatentation works as follows if you subclass this class:</span>

<span class="sd">                ConcatBasis = MyBasis1(properties1) + MyBasis2(properties2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_bounds</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="Basis.__init__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.Basis.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct this an instance of this class. This is also a good place</span>
<span class="sd">        to set non-learnable properties, and bounds on the parameters. An</span>
<span class="sd">        example Basis class with parameters may be,</span>

<span class="sd">        Example:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            def __init__(self, property, param_bounds=(1e-7, None)):</span>

<span class="sd">                self.property = property</span>
<span class="sd">                self.bounds = [params_bounds]</span>

<span class="sd">        All basis class objects MUST have a bounds property, which is either:</span>

<span class="sd">        -   an empty list</span>
<span class="sd">        -   a list of pairs of upper and lower bounds for each parameter.</span>
<span class="sd">            This is a concatenated list over all parameters, including</span>
<span class="sd">            vector parameters! See the minimize module for a guide on how</span>
<span class="sd">            these bounds work.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="Basis.__call__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.Basis.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the basis function applied to X, i.e. Phi(X, params), where</span>
<span class="sd">            params can also optionally be used and learned.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                X: (N, d) array of observations where N is the number of</span>
<span class="sd">                    samples, and d is the dimensionality of X.</span>
<span class="sd">                params: optional parameter aguments, these can be scalars or</span>
<span class="sd">                    arrays.</span>

<span class="sd">            Returns:</span>
<span class="sd">                array: of shape (N, D) where D is the number of basis</span>
<span class="sd">                    functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">X</span>
</div>
<div class="viewcode-block" id="Basis.grad"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.Basis.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the gradient of the basis function w.r.t. each of the</span>
<span class="sd">            parameters.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                X: (N, d) array of observations where N is the number of</span>
<span class="sd">                    samples, and d is the dimensionality of X.</span>
<span class="sd">                params: optional parameter aguments, these can be scalars or</span>
<span class="sd">                    arrays.</span>

<span class="sd">            Returns:</span>
<span class="sd">                list: with each element being an (N, D) array (same</span>
<span class="sd">                    dimensionality as return by __call__()) of a gradient with</span>
<span class="sd">                    respect to a parameter. The length of this list must be the</span>
<span class="sd">                    same as the *total* number of scalars in all of the</span>
<span class="sd">                    parameters, i.e. the same length as Basis.bounds.</span>

<span class="sd">                    The exception to this is if there are *no* parameters, in</span>
<span class="sd">                    which case a list of one element, containing an array of</span>
<span class="sd">                    (N, D) zeros must be returned.</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="c"># A bit inefficient, but it generalises well...</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get this objects parameter bounds. This is a list of pairs of upper</span>
<span class="sd">            and lower bounds, with the same length as the total number of</span>
<span class="sd">            scalars in all of the parameters combined (and in order).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span>

    <span class="nd">@bounds.setter</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set this objects parameter bounds. This is a list of pairs of upper</span>
<span class="sd">            and lower bounds, with the same length as the total number of</span>
<span class="sd">            scalars in all of the parameters combined (and in order).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">bounds</span>

<div class="viewcode-block" id="Basis.from_vector"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.Basis.from_vector">[docs]</a>    <span class="k">def</span> <span class="nf">from_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Apply this basis function to X like __call__(), but instead of</span>
<span class="sd">            being given parameter arguments, this function is given a flat list</span>
<span class="sd">            of all of the parameters. The parameters must be constructed from</span>
<span class="sd">            this list/vector in this function.</span>

<span class="sd">            This is primarily used for learning with an optimiser.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                X: (N, d) array of observations where N is the number of</span>
<span class="sd">                    samples, and d is the dimensionality of X.</span>
<span class="sd">                vec: a flat list or array containing a concatenation of all of</span>
<span class="sd">                    the flattened parameters. This list is of len(self.bounds).</span>

<span class="sd">            Returns:</span>
<span class="sd">                array: of shape (N, D) where D is the number of basis</span>
<span class="sd">                    functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Basis.grad_from_vector"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.Basis.grad_from_vector">[docs]</a>    <span class="k">def</span> <span class="nf">grad_from_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the gradient of the basis function w.r.t. each of the</span>
<span class="sd">            parameters, but like from_vector, instead of being given parameter</span>
<span class="sd">            arguments, this function is given a flat list of all of the</span>
<span class="sd">            parameters.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                X: (N, d) array of observations where N is the number of</span>
<span class="sd">                    samples, and d is the dimensionality of X.</span>
<span class="sd">                vec: a flat list or array containing a concatenation of all of</span>
<span class="sd">                    the flattened parameters. This list is of len(self.bounds).</span>

<span class="sd">            Returns:</span>
<span class="sd">                list: with each element being an (N, D) array (same</span>
<span class="sd">                    dimensionality as return by __call__()) of a gradient with</span>
<span class="sd">                    respect to a parameter. The length of this list must be the</span>
<span class="sd">                    same as the *total* number of scalars in all of the</span>
<span class="sd">                    parameters, i.e. the same length as vec.</span>

<span class="sd">                    The exception to this is if there are *no* parameters, in</span>
<span class="sd">                    which case a list of one element, containing an array of</span>
<span class="sd">                    (N, D) zeros must be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Basis.__add__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.Basis.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">BasisCat</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="Basis.__radd__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.Basis.__radd__">[docs]</a>    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="LinearBasis"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.LinearBasis">[docs]</a><span class="k">class</span> <span class="nc">LinearBasis</span><span class="p">(</span><span class="n">Basis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Linear basis class, basically this just prepending a columns of ones</span>
<span class="sd">        onto X.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LinearBasis.__init__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.LinearBasis.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onescol</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Construct a linear basis object.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                onescol: If true, prepend a column of ones onto X.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">onescol</span> <span class="o">=</span> <span class="n">onescol</span>
</div>
<div class="viewcode-block" id="LinearBasis.__call__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.LinearBasis.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return this basis applied to X.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                X: (N, d) array of observations where N is the number of</span>
<span class="sd">                    samples, and d is the dimensionality of X.</span>

<span class="sd">            Returns:</span>
<span class="sd">                array: of shape (N, d+1), or (N, d) depending on onescol.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">X</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">onescol</span> <span class="k">else</span> <span class="n">X</span>

</div></div>
<div class="viewcode-block" id="PolynomialBasis"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.PolynomialBasis">[docs]</a><span class="k">class</span> <span class="nc">PolynomialBasis</span><span class="p">(</span><span class="n">Basis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Polynomial basis class, this essentially creates the concatenation,</span>
<span class="sd">        Phi = [X^0, X^1, ..., X^p] where p is specified in the constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PolynomialBasis.__init__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.PolynomialBasis.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">include_bias</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Construct a polynomial basis object.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                order: the order of the polynomial to create, i.e. the last</span>
<span class="sd">                    power to raise X to in the concatenation Phi = [X^0, X^1,</span>
<span class="sd">                    ..., X^order].</span>
<span class="sd">                include_bias: If True (default), include the bias column</span>
<span class="sd">                    (column of ones which acts as the intercept term in a</span>
<span class="sd">                    linear model)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Polynomial order must be positive&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">include_bias</span> <span class="o">=</span> <span class="n">include_bias</span>
</div>
<div class="viewcode-block" id="PolynomialBasis.__call__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.PolynomialBasis.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return this basis applied to X.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                X: (N, d) array of observations where N is the number of</span>
<span class="sd">                    samples, and d is the dimensionality of X.</span>

<span class="sd">            Returns:</span>
<span class="sd">                array: of shape (N, d*order+1), the extra 1 is from a</span>
<span class="sd">                    prepended ones column.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">pow_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c"># Polynomial terms</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">**</span> <span class="n">pow_arr</span>

        <span class="c"># Flatten along last axes</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>

        <span class="c"># Prepend intercept</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_bias</span><span class="p">:</span>
            <span class="n">Phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">Phi</span><span class="p">))</span>

        <span class="c"># TODO: Using np.hstack is about 4x slower than initializing, say,</span>
        <span class="c"># an N by d*order+1 ndarray of ones and assigning the remaining</span>
        <span class="c"># N by d*order values. May want to revisit this implementation.</span>

        <span class="k">return</span> <span class="n">Phi</span>

</div></div>
<div class="viewcode-block" id="RadialBasis"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RadialBasis">[docs]</a><span class="k">class</span> <span class="nc">RadialBasis</span><span class="p">(</span><span class="n">Basis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Radial basis class.</span>

<span class="sd">    Note:</span>
<span class="sd">        This will have relevance vector machine-like behaviour with</span>
<span class="sd">        uncertainty and for deaggregation tasks!</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RadialBasis.__init__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RadialBasis.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centres</span><span class="p">,</span> <span class="n">lenscale_bounds</span><span class="o">=</span><span class="n">Positive</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a radial basis function (RBF) object.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            centres:    array of shape (Dxd) where D is the number of centres</span>
<span class="sd">                        for the radial bases, and d is the dimensionality of X.</span>

<span class="sd">            lenscale_bounds: a tuple of bounds for the RBFs&#39; length scales.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">centres</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">centres</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">lenscale_bounds</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="RadialBasis.__call__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RadialBasis.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lenscale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the RBF to X.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            X:  (N, d) array of observations where N is the number of</span>
<span class="sd">                samples, and d is the dimensionality of X.</span>

<span class="sd">            lenscale: the length scale (scalar) of the RBFs to apply to X.</span>

<span class="sd">        Returns:</span>
<span class="sd">            array:  of shape (N, D) where D is number of RBF centres.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">!=</span> <span class="n">D</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;X has inconsistent dimensionality!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="s">&#39;sqeuclidean&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lenscale</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="RadialBasis.grad"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RadialBasis.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lenscale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the gradients of this basis w.r.t. the length scale.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            X:  (N, d) array of observations where N is the number of</span>
<span class="sd">                samples, and d is the dimensionality of X.</span>

<span class="sd">            lenscale: the length scale (scalar) of the RBFs to apply to X.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list:   with one element of shape (N, D) where D is number of RBF</span>
<span class="sd">                    centres. This is d Phi(X) / d lenscale.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">!=</span> <span class="n">D</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;X has inconsistent dimensionality!&quot;</span><span class="p">)</span>

        <span class="n">sdist</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="s">&#39;sqeuclidean&#39;</span><span class="p">)</span>
        <span class="n">dPhi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">sdist</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lenscale</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">sdist</span> <span class="o">/</span> <span class="n">lenscale</span><span class="o">**</span><span class="mi">3</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">dPhi</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="RadialBasis.from_vector"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RadialBasis.from_vector">[docs]</a>    <span class="k">def</span> <span class="nf">from_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="RadialBasis.grad_from_vector"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RadialBasis.grad_from_vector">[docs]</a>    <span class="k">def</span> <span class="nf">grad_from_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c"># TODO: Might be worth creating a mixin or base class for basis functions</span>
<span class="c"># that require locations and scales</span>

</div></div>
<div class="viewcode-block" id="SigmoidalBasis"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.SigmoidalBasis">[docs]</a><span class="k">class</span> <span class="nc">SigmoidalBasis</span><span class="p">(</span><span class="n">Basis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sigmoidal Basis&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SigmoidalBasis.__init__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.SigmoidalBasis.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centres</span><span class="p">,</span> <span class="n">lenscale_bounds</span><span class="o">=</span><span class="n">Positive</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Construct a sigmoidal basis function object.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            centres: array of shape (Dxd) where D is the number of centres</span>
<span class="sd">                for the bases, and d is the dimensionality of X.</span>
<span class="sd">            lenscale_bounds: a tuple of bounds for the basis function length</span>
<span class="sd">                scales.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">centres</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">centres</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">lenscale_bounds</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="SigmoidalBasis.__call__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.SigmoidalBasis.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lenscale</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Apply the sigmoid basis function to X.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \phi_j (x) = \sigma \left ( \frac{\| x - \mu_j \|_2}{s} \right )</span>

<span class="sd">        where :math:`\sigma` is the logistic sigmoid function defined by</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sigma(a) = \frac{1}{1+e^{-a}}</span>

<span class="sd">        Arguments:</span>
<span class="sd">            X: (N, d) array of observations where N is the number of</span>
<span class="sd">                samples, and d is the dimensionality of X.</span>
<span class="sd">            lenscale: the length scale (scalar) of the basis functions to</span>
<span class="sd">                apply to X.</span>

<span class="sd">        Returns:</span>
<span class="sd">            array: of shape (N, D) where D is number of centres.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">!=</span> <span class="n">D</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Expected X of dimensionality {0}, got {1}&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">expit</span><span class="p">(</span><span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="s">&#39;seuclidean&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">lenscale</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SigmoidalBasis.grad"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.SigmoidalBasis.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lenscale</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Get the gradients of this basis w.r.t. the length scale.</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{\partial}{\partial s} \phi_j(x) =</span>
<span class="sd">            - \frac{\| x - \mu_j \|_2}{s^2}</span>
<span class="sd">            \sigma \left ( \frac{\| x - \mu_j \|_2}{s} \right )</span>
<span class="sd">            \left ( 1 - \sigma \left ( \frac{\| x - \mu_j \|_2}{s} \right )</span>
<span class="sd">            \right )</span>

<span class="sd">        Arguments:</span>
<span class="sd">            X: (N, d) array of observations where N is the number of</span>
<span class="sd">                samples, and d is the dimensionality of X.</span>

<span class="sd">            lenscale: the length scale (scalar) of the  to apply to X.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: with one element of shape (N, D) where D is number of</span>
<span class="sd">                centres. This is d Phi(X) / d lenscale.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">!=</span> <span class="n">D</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Expected X of dimensionality {0}, got {1}&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="s">&#39;seuclidean&#39;</span><span class="p">)</span>

        <span class="n">sigma</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">lenscale</span><span class="p">)</span>

        <span class="n">dPhi</span> <span class="o">=</span> <span class="o">-</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">/</span> <span class="n">lenscale</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">dPhi</span><span class="p">]</span>

</div></div>
<div class="viewcode-block" id="RandomRBF"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF">[docs]</a><span class="k">class</span> <span class="nc">RandomRBF</span><span class="p">(</span><span class="n">RadialBasis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Random RBF Basis, otherwise known as Random Kitchen Sinks.</span>

<span class="sd">    This will make a linear regression model approximate a GP with an RBF</span>
<span class="sd">    covariance function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandomRBF.__init__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbases</span><span class="p">,</span> <span class="n">Xdim</span><span class="p">,</span> <span class="n">lenscale_bounds</span><span class="o">=</span><span class="n">Positive</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a random radial basis function (RBF) object.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            nbases: a scalar for how many random bases to create.</span>

<span class="sd">            Xdim: the dimension (d) of the observations.</span>

<span class="sd">            lenscale_bounds: a tuple of bounds for the RBFs&#39; length scales.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">Xdim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">nbases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">lenscale_bounds</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="RandomRBF.__call__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lenscale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the random RBF to X.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            X:  (N, d) array of observations where N is the number of</span>
<span class="sd">                samples, and d is the dimensionality of X.</span>

<span class="sd">            lenscale: the length scale (scalar) of the RBFs to apply to X.</span>

<span class="sd">        Returns:</span>
<span class="sd">            array:  of shape (N, 2*nbases) where nbases is number of random</span>
<span class="sd">                    bases to use, given in the constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkD</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

        <span class="n">WX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">/</span> <span class="n">lenscale</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">WX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">WX</span><span class="p">)))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RandomRBF.grad"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lenscale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the gradients of this basis w.r.t. the length scale.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            X:  (N, d) array of observations where N is the number of</span>
<span class="sd">                samples, and d is the dimensionality of X.</span>

<span class="sd">            lenscale: the length scale (scalar) of the RBFs to apply to X.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list:   with one element of shape (N, 2*nbases) where nbases is</span>
<span class="sd">                    number of random RBF bases. This is d Phi(X) / d lenscale.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkD</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

        <span class="n">WX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">/</span> <span class="n">lenscale</span><span class="p">)</span>
        <span class="n">dWX</span> <span class="o">=</span> <span class="o">-</span> <span class="n">WX</span> <span class="o">/</span> <span class="n">lenscale</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="o">-</span><span class="n">dWX</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">WX</span><span class="p">),</span> <span class="n">dWX</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">WX</span><span class="p">)))</span>
                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>
</div>
<div class="viewcode-block" id="RandomRBF._checkD"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF._checkD">[docs]</a>    <span class="k">def</span> <span class="nf">_checkD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">D</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Dimensions of data inconsistent!&quot;</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="RandomRBF_ARD"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF_ARD">[docs]</a><span class="k">class</span> <span class="nc">RandomRBF_ARD</span><span class="p">(</span><span class="n">RandomRBF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Random RBF Basis, otherwise known as Random Kitchen Sinks, with</span>
<span class="sd">        automatic relevance determination (ARD).</span>

<span class="sd">        This will make a linear regression model approximate a GP with an</span>
<span class="sd">        ARD-RBF covariance function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RandomRBF_ARD.__init__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF_ARD.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbases</span><span class="p">,</span> <span class="n">Xdim</span><span class="p">,</span> <span class="n">lenscale_bounds</span><span class="o">=</span><span class="n">Positive</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot; Construct a random radial basis function (RBF) object, with ARD.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                nbases: a scalar for how many random bases to create.</span>
<span class="sd">                Xdim: the dimension (d) of the observations.</span>
<span class="sd">                lenscale_bounds: a tuple of bounds for the RBFs&#39; length scales.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">RandomRBF_ARD</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">nbases</span><span class="p">,</span> <span class="n">Xdim</span><span class="p">,</span> <span class="n">lenscale_bounds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">*=</span> <span class="n">Xdim</span>
</div>
<div class="viewcode-block" id="RandomRBF_ARD.__call__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF_ARD.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lenscales</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Apply the random ARD-RBF to X.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                X: (N, d) array of observations where N is the number of</span>
<span class="sd">                    samples, and d is the dimensionality of X.</span>
<span class="sd">                lenscale: array of shape (d,) length scales (one for each</span>
<span class="sd">                    dimension of X).</span>

<span class="sd">            Returns:</span>
<span class="sd">                array: of shape (N, 2*nbases) where nbases is number of random</span>
<span class="sd">                    bases to use, given in the constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkD</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lenscales</span><span class="p">))</span>

        <span class="n">WX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">/</span> <span class="n">lenscales</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">WX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">WX</span><span class="p">)))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RandomRBF_ARD.grad"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF_ARD.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lenscales</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the gradients of this basis w.r.t. the length scales.</span>

<span class="sd">            Arguments:</span>
<span class="sd">                X: (N, d) array of observations where N is the number of</span>
<span class="sd">                    samples, and d is the dimensionality of X.</span>
<span class="sd">                lenscale: array of shape (d,) length scales (one for each</span>
<span class="sd">                    dimension of X).</span>

<span class="sd">            Returns:</span>
<span class="sd">                list: with d arrays of shape (N, 2*nbases) where nbases is</span>
<span class="sd">                    number of random RBF bases. This is d Phi(X) / d lenscale</span>
<span class="sd">                    for each length scale parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkD</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lenscales</span><span class="p">))</span>

        <span class="n">WX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">/</span> <span class="n">lenscales</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="n">sinWX</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">WX</span><span class="p">)</span>
        <span class="n">cosWX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">WX</span><span class="p">)</span>

        <span class="n">dPhi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lenscales</span><span class="p">):</span>
            <span class="n">dWX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">l</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">dPhi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dWX</span> <span class="o">*</span> <span class="n">sinWX</span><span class="p">,</span> <span class="n">dWX</span> <span class="o">*</span> <span class="n">cosWX</span><span class="p">))</span>
                        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dPhi</span>
</div>
<div class="viewcode-block" id="RandomRBF_ARD.from_vector"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF_ARD.from_vector">[docs]</a>    <span class="k">def</span> <span class="nf">from_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RandomRBF_ARD.grad_from_vector"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF_ARD.grad_from_vector">[docs]</a>    <span class="k">def</span> <span class="nf">grad_from_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RandomRBF_ARD._checkD"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.RandomRBF_ARD._checkD">[docs]</a>    <span class="k">def</span> <span class="nf">_checkD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xdim</span><span class="p">,</span> <span class="n">lendim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">Xdim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Dimensions of data inconsistent!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lendim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Dimensions of lenscale inconsistent!&quot;</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="FastFood"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.FastFood">[docs]</a><span class="k">class</span> <span class="nc">FastFood</span><span class="p">(</span><span class="n">RandomRBF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fast Food basis function, which is an approximation of the random</span>
<span class="sd">    radial basis function for a large number of bases.</span>

<span class="sd">    This will make a linear regression model approximate a GP with an RBF</span>
<span class="sd">    covariance function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FastFood.__init__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.FastFood.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbases</span><span class="p">,</span> <span class="n">Xdim</span><span class="p">,</span> <span class="n">lenscale_bounds</span><span class="o">=</span><span class="n">Positive</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a random radial basis function (RBF) object.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            nbases: a scalar for how many random bases to create</span>
<span class="sd">                    approximately, this actually will be to the neareset larger</span>
<span class="sd">                    two power.</span>

<span class="sd">            Xdim:   the dimension (d) of the observations.</span>
<span class="sd">                    lenscale_bounds: a tuple of bounds for the RBFs&#39; length</span>
<span class="sd">                    scales.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">lenscale_bounds</span><span class="p">]</span>

        <span class="c"># Make sure our dimensions are powers of 2</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">Xdim</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">Xdim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nbases</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">d2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>

        <span class="c"># Draw consistent samples from the covariance matrix</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__sample_params</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PI</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="FastFood.__call__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.FastFood.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lenscale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the Fast Food RBF basis to X.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            X:  (N, d) array of observations where N is the number of</span>
<span class="sd">                samples, and d is the dimensionality of X.</span>

<span class="sd">            lenscale: the length scale (scalar) of the RBFs to apply to X.</span>

<span class="sd">        Returns:</span>
<span class="sd">            array:  of shape (N, 2*nbases) where nbases is number of random</span>
<span class="sd">                    bases to use, given in the constructor (to nearest larger</span>
<span class="sd">                    two power).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_checkD</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">VX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__makeVX</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="n">lenscale</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">VX</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">VX</span><span class="p">)))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Phi</span>
</div>
<div class="viewcode-block" id="FastFood.grad"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.FastFood.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">lenscale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the gradients of this basis w.r.t. the length scale.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            X:  (N, d) array of observations where N is the number of</span>
<span class="sd">                samples, and d is the dimensionality of X.</span>

<span class="sd">            lenscale: the length scale (scalar) of the RBFs to apply to X.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list:   with one element of shape (N, 2*nbases) where nbases is</span>
<span class="sd">                    number of random RBF bases, again to the nearest larger</span>
<span class="sd">                    two power. This is d Phi(X) / d lenscale.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_checkD</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">VX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__makeVX</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="n">lenscale</span>
        <span class="n">dVX</span> <span class="o">=</span> <span class="o">-</span> <span class="n">VX</span> <span class="o">/</span> <span class="n">lenscale</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="o">-</span><span class="n">dVX</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">VX</span><span class="p">),</span> <span class="n">dVX</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">VX</span><span class="p">)))</span>
                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>
</div>
    <span class="k">def</span> <span class="nf">__sample_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># uniform from [-1,1]</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d2</span><span class="p">)</span>  <span class="c"># mean 0 std 1</span>
        <span class="n">PI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d2</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gammaincinv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d2</span><span class="p">)))</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">PI</span><span class="p">,</span> <span class="n">S</span>

    <span class="k">def</span> <span class="nf">__makeVX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">d0</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="c"># Pad the dimensions of X to nearest 2 power</span>
        <span class="n">X_dash</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d2</span><span class="p">))</span>
        <span class="n">X_dash</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">d0</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>

        <span class="n">VX</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">PI</span><span class="p">,</span> <span class="n">S</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PI</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)):</span>
            <span class="n">vX</span> <span class="o">=</span> <span class="n">hadamard</span><span class="p">(</span><span class="n">X_dash</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ordering</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">vX</span> <span class="o">=</span> <span class="n">vX</span><span class="p">[:,</span> <span class="n">PI</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">VX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hadamard</span><span class="p">(</span><span class="n">vX</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                      <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">VX</span><span class="p">)</span>


<span class="c">#</span>
<span class="c"># Other basis construction objects and functions</span>
<span class="c">#</span>
</div>
<div class="viewcode-block" id="BasisCat"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.BasisCat">[docs]</a><span class="k">class</span> <span class="nc">BasisCat</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A class that implements concatenation of bases. &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BasisCat.__init__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.BasisCat.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basis_list</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bases</span> <span class="o">=</span> <span class="n">basis_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbases</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nparams_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">]</span>

        <span class="c"># Lists for convenient indexing of parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__beg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nparams_list</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nparams_list</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BasisCat.__call__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.BasisCat.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_vector</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">params_to_list</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BasisCat.from_vector"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.BasisCat.from_vector">[docs]</a>    <span class="k">def</span> <span class="nf">from_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>

        <span class="n">Phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">from_vector</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="n">b</span><span class="p">:</span><span class="n">e</span><span class="p">])</span>
               <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__beg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__end</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">Phi</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BasisCat.grad_from_vector"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.BasisCat.grad_from_vector">[docs]</a>    <span class="k">def</span> <span class="nf">grad_from_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>

        <span class="c"># Get the gradients from each basis in list of lists</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">grad_from_vector</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="n">b</span><span class="p">:</span><span class="n">e</span><span class="p">])</span>
                 <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__beg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__end</span><span class="p">)]</span>

        <span class="c"># Now combine the padded arrays and gradient in correct positions</span>
        <span class="n">dPhis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">glist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grads</span><span class="p">):</span>

            <span class="c"># Ignore bases with no gradients</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nparams_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c"># Pad gradient with relevant zeros for other bases</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">glist</span><span class="p">:</span>
                <span class="n">dPhi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grads</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="k">else</span> <span class="n">g</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbases</span><span class="p">)]</span>
                <span class="n">dPhis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">dPhi</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dPhis</span>
</div>
<div class="viewcode-block" id="BasisCat.grad"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.BasisCat.grad">[docs]</a>    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_from_vector</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">params_to_list</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">bounds</span>

        <span class="k">return</span> <span class="n">bounds</span>

<div class="viewcode-block" id="BasisCat.__add__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.BasisCat.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BasisCat</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BasisCat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bases</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">bases</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BasisCat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bases</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="BasisCat.__radd__"><a class="viewcode-back" href="../../bases.html#pyalacarte.bases.BasisCat.__radd__">[docs]</a>    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyalacarte 0.1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Daniel Steinberg, Louis Tiao, Lachlan McCalman, Alistair Reid.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>